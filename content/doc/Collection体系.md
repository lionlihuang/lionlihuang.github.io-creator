---
title: "Collection体系"
date: 2020-05-28T14:44:39+08:00
draft: false
---
# Collection体系的常用类及其背后的数据结构
List
ArrayList：
背后是一个动态数组，有序插入元素，可以根据下标取得对应元素，检索元素为线性查找，效率较低。当容量不足时会自动扩容，每次新建一个新的List，大小为原来的1.5倍，再将所有元素拷贝到新的List中去。
LinkedList：
背后是一个链表结构，有序插入元素，可以根据下标取得对应元素， 检索时从头部或者尾部不断向下标靠拢，所以头部和尾部的查找效率高，中间低。
Set
HashSet：
计算出元素的哈希值，哈希值相同的元素放在同一个哈希桶里，每个哈希桶里维护一个链表。插入的元素是无序的且不允许出现重复元素，查找效率高。但当发生哈希碰撞时，整个结构退化为链表会导致性能急剧下降。
LinkedHashSet：
不同于HashSet，前面的数据结构为链表，所以是有序的，其他几乎一样。
TreeSet：
前面的数据结构为二叉树，可以对插入的元素进行排序。检索快，时间复杂度降为对数级。
Map
HashMap：
实质上和HashSet一样，不过可以存储键（Key）到值（Value）的映射。JDK1.8之后当链表节点大于7时会裂变为红黑树。
TreeMap：
可以排序的HashMap。
# Collection体系的常用类及其背后的数据结构对比
# ArrayList源码阅读 
成员变量
构造函数
添加元素方法
插入
添加集合方法
移除元素方法
删除元素
查询
从前往后查找第一个出现的元素
集合运算
# ArrayList是如何扩容的？
写过的项目到现在基本上面向业务域查询返回大列表都是使用ArrayList来存储业务数据的。

定义：ArrayList是List接口的可变数组的实现。实现了所有的可选列表的操作并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。

每个ArrayList实例都有一个容量，该容量是指来存储列表元素的数组的大小，该容量至少等于列表数组的大小，随着ArrayList的不断添加元素，其容量也在自动增长，自动增长会将原来数组的元素向新的数组进行copy。因此，如果根据业务场景来提前预判数据量的大小。可在构造ArrayList时指定其容量。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加ArrayList实例的容量，这样就可以减少递增式再分配数量的操作。

注意：我们都知道ArrayList不是线程安全的，如果存在多线程访问ArrayList实例的场景，其中一个线程要在改变ArrayList列表结构之前，需要先对它这个操作保持线程同步。
ArrayList是采取延迟分配对象数组大小空间的，当第一次添加元素时才会分配10个对象空间，当添加第11个元素的时候，会扩容1.5倍，当添加到16个元素的时候扩容为15*1.5=22，以此类推。
# HashMap源码阅读
构造方法一共重载了四个，主要初始化了三个参数：

initialCapacity 初始容量（默认16）： hashMap底层由数组实现+链表（或红黑树）实现，但是还是从数组开始，所以当储存的数据越来越多的时候，就必须进行扩容操作，如果在知道需要储存数据大小的情况下，指定合适的初始容量，可以避免不必要的扩容操作，提升效率
threshold 阈值：hashMap所能容纳的最大价值对数量，如果超过则需要扩容，计算方式：threshold=initialCapacity*loadFactor（构造方法中直接通过tableSizeFor(initialCapacity)方法进行了赋值，主要原因是在构造方法中，数组table并没有初始化，put方法中进行初始化，同时put方法中也会对threshold进行重新赋值，这个会在后面的源码中进行分析）
loadFactor 加载因子（默认0.75）：当负载因子较大时，去给table数组扩容的可能性就会少，所以相对占用内存较少（空间上较少），但是每条entry链上的元素会相对较多，查询的时间也会增长（时间上较多）。反之就是，负载因子较少的时候，给table数组扩容的可能性就高，那么内存空间占用就多，但是entry链上的元素就会相对较少，查出的时间也会减少。所以才有了负载因子是时间和空间上的一种折中的说法。所以设置负载因子的时候要考虑自己追求的是时间还是空间上的少。（一般情况下不需要设置，系统给的默认值已经比较适合了）

我们最常使用的是无参构造，在这个构造方法里面仅仅设置了加载因子为默认值，其他两个参数会在resize方法里面进行初始化，在这里知道这个结论就可以了，下面会在源码里面进行分析；
另外一个带有两个参数的构造方法，里面对初始容量和阈值进行了初始化，对阈值的初始化方法为 tableSizeFor(int cap)
put方法
 table尚未初始化
 get方法，查找
 取模运算 (n - 1) & hash
 remove方法，删除
 其他源码
到这里，hashMap的源码基本就解析完成了，其余的方法和源码逻辑相对非常简单，大部分还是使用上述代码来实现的，例如containsKey（jey），就是使用get方法中的getNode（）来判断的，由于篇幅原因就不一一介绍。
另外，中间有很部分不影响逻辑理解的代码被一笔带过，比如 红黑树的转化，查找，删除等操作，有兴趣的可以自己进行学习，不过还有一些其他的特性需要提醒一下
最后总结一下：

HashMap 底层数据结构在JDK1.7之前是由数组+链表组成的，1.8之后又加入了红黑树；链表长度小于8的时候，发生Hash冲突后会增加链表的长度，当链表长度大于8的时候，会先判读数组的容量，如果容量小于64会先扩容（原因是数组容量越小，越容易发生碰撞，因此当容量过小的时候，首先要考虑的是扩容），如果容量大于64，则会将链表转化成红黑树以提升效率
hashMap 的容量是2的n次幂，无论在初始化的时候传入的初始容量是多少，最终都会转化成2的n次幂，这样做的原因是为了在取模运算的时候可以使用&运算符，而不是%取余，可以极大的提上效率，同时也降低hash冲突
HashMap是非线程安全的，在多线程的操作下会存在异常情况（如形成闭环（1.7），1.8已修复闭环问题，但仍不安全），可以使用HashTable或者ConcurrentHashMap进行代替
# HashMap是如何扩容的？
当map中包含的Entry的数量大于等于threshold = loadFactor * capacity的时候，且新建的Entry刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍。（为什么2倍，而不是1.5倍，3倍，10倍；解释见最后的补充）

当size大于等于threshold的时候，并不一定会触发扩容机制，但是会很可能就触发扩容机制，只要有一个新建的Entry出现哈希冲突，则立刻resize

# HashMap从Java7到Java8发生了哪些变化？
JDK8中旧链表迁移新链表，链表元素相对位置没有变化; 实际是对对象的内存地址进行操作
在JDK7中旧链表迁移新链表，如果在新表的数组索引位置相同，则链表元素会倒置。
JDK8中的HashMap虽然有了很大变化，但它依然还是线程不安全的，所以在平常使用时，可能会感觉不到它的变化，但知道其内部原理后，在处理多少数据量的时候选用hashMap来存储就有了更清晰的认识。

# 为什么HashMap不是线程安全的？
LinkedHashMap、TreeMap，HashTable。HashMap根据key的hashCode值来保存value，需要注意的是，HashMap不保证遍历的顺序和插入的顺序是一致的。HashMap允许有一条记录的key为null，但是对值是否为null不做要求。HashTable类是线程安全的，它使用synchronize来做线程安全，全局只有一把锁，在线程竞争比较激烈的情况下hashtable的效率是比较低下的。因为当一个线程访问hashtable的同步方法时，其他线程再次尝试访问的时候，会进入阻塞或者轮询状态，比如当线程1使用put进行元素添加的时候，线程2不但不能使用put来添加元素，而且不能使用get获取元素。所以，竞争会越来越激烈。相比之下，ConcurrentHashMap使用了分段锁技术来提高了并发度，不在同一段的数据互相不影响，多个线程对多个不同的段的操作是不会相互影响的。每个段使用一把锁。所以在需要线程安全的业务场景下，推荐使用ConcurrentHashMap，而HashTable不建议在新的代码中使用，如果需要线程安全，则使用ConcurrentHashMap，否则使用HashMap就足够了。

LinkedHashMap属于HashMap的子类，与HashMap的区别在于LinkedHashMap保存了记录插入的顺序。TreeMap实现了SortedMap接口，TreeMap有能力对插入的记录根据key排序，默认按照升序排序，也可以自定义比较强，在使用TreeMap的时候，key应当实现Comparable。

二、HashMap的实现

java7和java8在实现HashMap上有所区别，当然java8的效率要更好一些，主要是java8的HashMap在java7的基础上增加了红黑树这种数据结构，使得在桶里面查找数据的复杂度从O(n)降到O(logn)，当然还有一些其他的优化，比如resize的优化等。
介于java8的HashMap较为复杂，本文将基于java7的HashMap实现来说明，主要的实现部分还是一致的，java8的实现上主要是做了一些优化，内容还是没有变化的，依然是线程不安全的。
HashMap的实现使用了一个数组，每个数组项里面有一个链表的方式来实现，因为HashMap使用key的hashCode来寻找存储位置，不同的key可能具有相同的hashCode，这时候就出现哈希冲突了，也叫做哈希碰撞，为了解决哈希冲突，有开放地址方法，以及链地址方法。HashMap的实现上选取了链地址方法，也就是将哈希值一样的entry保存在同一个数组项里面，可以把一个数组项当做一个桶，桶里面装的entry的key的hashCode是一样的。
